# 오브젝트와 의존관계


`스프링은.. 오브젝트를 어떻게 설계하고 구현하고 사용하고 이를 개선해 나갈 것인가에 대한 명쾌한 기준을 마련해주며,
동시에 객체지향 기술과 설계, 구현에 관한 실용적인 전략과 검증된 베스트 프랙티스를 평범한 개발자도 자연스럽고 손쉽게
적용할 수 있도록 프레임워크 형태로 제공한다.`

스프링이 가장 관심을 많이두는 대상은 **오브젝트**

## 목표
오브젝트의 설계와 구현, 동작원리에 집중한다.

> ### JAVA Bean
>> ####관례
>> 디폴트 생성자 : 파라미터가 없는 디폴트 생성자를 갖고있어야 함, 툴이나 프레임워크에서 리플렉션을 이용해
>> 오브젝트를 생성하기 때문에 필요
>>
>> 프로퍼티 : set으로 시작하는 수정자메서드(setter)와 get으로 시작하는 접근자메서드(getter)를 이용해 수정, 조회 할 수 있음

## 관심사 분리

미래의 변화를 어떻게 대비할 것인가.

변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다.

> 변화가 한번에 한 가지 관심에 집중돼서 일어난다면, 우리가 준비할 것은 **한 가지 관심이 한 군데에 집중되게 하는것**
>> 관심이 같은 것끼리는 하나의 객체 안으로 또는 친한 객체로 모이게하고, 관심이 다른 것은 가능한 한 따로 떨어져서 영향을 주지 않도록 분리하는 것
>> 기초 개념 중 관심사의 분리 (Separation of Concerns)

 
## 중복 코드의 메서드 호출
공통의 기능을 담당하는 메서드로 중복된 코드를 뽑아내는 것을 리펙토링에서는 메서드 추출(extract method)기법이라고 부른다.
> ## 리펙토링
>> 기존의 코드를 외부의 동작방식에는 변화 없이 내부 구조를 변경해서 재구성하는 작업
>> 코드 내부의 설계가 개선되어 코드를 이해하기가 더 편해지고, 변화에 효율적으로 대응할 수 있다.
>> 생산성은 올라가고, 코드의 품질은 높아지며, 유지보수하기 용이하고 견고하고 유연하다.
>> 
>> 리펙토링이 절실히 필요한 코드의 특징을 나쁜 냄새라고 부르기도 하며, 대표적으로 중복된 코드는 매우 흔하게 발견되는 나쁜 냄새다.
 
## 변경사항에 대한 검증 : 리펙토링과 테스트
## 상속을 통한 확장

## 개방 폐쇄 원칙 (OCP open-closed principle)
클래스나 모듈은 확장에는 열려있고 변화에는 닫혀있어야 한다.

## 높은 응집도와 낮은 결합도
응집도가 높다는 건 하나의 모듈, 클래스가 하나의 책임 또는 하나의 관심사에만 집중되어 있다는 뜻.
불필요하거나 직접 관련이 없는 외부의 관심과 책임이 얽혀 있지 않으며 `하나의 공통 관심사는 한 클래스에 모여있다.`
높은 응집도는 클래스 레밸뿐만 아니라 패키지, 컴포넌트 모듈에 이르기까지 그 대상의 크기가 달라도 동일한 원리로 적용될 수 있다.

e.g. 처음 초난감 DAO에서 DB 커넥션 만드는 방법을 교체한다고 할때 초난감 DAO 처럼 여러 관심사와 책임이 얽혀 있는 복잡한 코드에서는
변경이 필요한 부분을 찾아내는 것도 번거러운 일일뿐더러 그렇게 변경한 것이 다른 기능에 영향을 줘서 오류를 발생시키는지도 일일이 확인해야함
반면 인터페이스를 이용해 DB 연결 기능을 독립시킨 경우라면 구현 클래스를 새로 만들기만 하면되고 기존에 구현한 것을 수정하는 경우도 마찬가지,

작업은 항상 전체적으로 일어나고 무엇을 변경할지 명확하며, 그것이 DAO등 다른 클래스의 수정을 요구하지 않을 뿐더러
기능에 영향을 주지 않는다는 사실을 손쉽게 확인할 수 있다.

낮은 결합도는 높은 응집도보다 더 민감한 원칙, 책임과 관심사가 다른 오브젝트 또는 모듈과는 낮은 결합도, 즉 느슨하게
연결된 형태를 유지하는 것이 바람직하다. 

> 결합도란 하나의 오브젝트가 변경이 일어날 때에 관계를 맺고 있는 다른 오브젝트에게 변화를 요구하는 정도

## 제어의 역전(IOC inversion of control)
UserDaoTest 클래스는 이전에 UserDao가 담당하던, 어떤 ConnectionMaker 구현클래스를 사용할지에 대한 관심을
엉겁결에 떠맡게됨. 이는 UserDao를 특정 클래스로부터 독립할 수 있게 클라이언트에게 임무를 넘긴것이다.

분리될 기능은 UserDao와 ConnectionMaker의 오브젝트를 만드는 것과 두개의 관계를 맺어주는 기능이다.

### 팩토리
객체의 생성 방법을 결정하고 그렇게 만들어진 객체를 반환한다. 이런 기능을 하는 오브젝트를 팩토리라고 한다.
> 추상 팩토리 패턴, 팩토리 메소드 패턴과는 다르다.

팩토리 메서드는 어플리케이션을 구성하고 관계를 정의하는 책임을 맡게되고, 구조와 관계를 정의한 설계도
같은 역할을 한다고 볼 수 있다.

### 제어권의 이전을 통한 제어관계 역전
보통 각 오브젝트는 프로그램의 흐름을 결정하거나 사용할 오브젝트를 구성하는 작업에 능동적으로 참여한다.
자신이 사용할 클래스를 결정하고, 언제 어떻게 그 오브젝트를 만들지를 스스로 관장한다는 것이다. 즉,
모든 종류의 작업을 사용하는 쪽에서 제어하는 식이다.

제어의 역전이란 이런 제어 흐름의 개념을 거꾸로 뒤집는 것이다. 오브젝트가 자신이 사용할 오브젝트를 스스로 선택하지 않고
생성하지도 않는다. 또한 자신도 어디서 만들어지고 사용되는지 알 수 없다. **모든 제어 권한을 자신이 아닌
다른 대상에게 위임하기 때문이다.**

제어의 역전 개념은 사실 이미 폭넓게 적용되어있으며 서블릿을 생각해보면 알 수 있다. 서블릿에
main 메서드가 있던가?  아니다, 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고
그 안의 메서드를 호출한다. 

프레임워크가 제어의 역전 개념이 적용된 대표적인 기술이다.

> 라이브러리
>> 라이브러리를 사용하여 작성한 코드는 어플리케이션 흐름을 직접 제어한다.
 
> 프레임워크
>> 내가 작성한 어플리케이션 코드가 프레임워크에 의해 사용된다.
>> 보통 프레임워크 위에 개발한 클래스를 등록해두고, 프레임워크가 흐름을 주도하는 중에 내가 작성한 코드를
>> 사용하도록 만드는 방식이다.
> 

